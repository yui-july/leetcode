【answer1:切片字符串，效率最高且简单！】

```python
class Solution:
    def reverseLeftWords(self, s: str, n: int) -> str:
        a = s[n::]
        b = s[:n]
        return a + b
```



【answer2：简化版写法！自己想到的！我好棒！虽然一开始是想用lambda解决...然后发现不可以！啊这道题果然很简单qwq我爱简单的题】

```python
class Solution:
    def reverseLeftWords(self, s: str, n: int) -> str:
        return s[n:] + s[:n]
```



【answer3：看解析的解答！如果不能切片字符串的话】

```python
class Solution:
    def reverseLeftWords(self, s: str, n: int) -> str:
        res = ''
        for i in range(n,len(s)):
            res += s[i]
        for i in range(n):
            res += s[i]
        return res
```

【用求余运算进行简化！】

```python
class Solution:
    def reverseLeftWords(self, s: str, n: int) -> str:
        res = ''
        for i in range(n,n + len(s)):
            res += s[i % len(s)]
        return res
```

但是效率极差，为什么呢！想一想！

因为字符串res是不可迭代的！

【字符串是 “不可变对象” 。因此，每轮遍历拼接字符时，都需要新建一个字符串；因此，系统 **需申请 N次内存** ，数据量较大时效率低下。】

![旋转字符](F:\Github\leetcode\Str字符串\左旋转字符串.png)

所以这个方法是效率最低的！



【answer4：不用切片又有效率的方法，就是图片上的方法二啦】

```python
class Solution:
    def reverseLeftWords(self, s: str, n: int) -> str:
        res = []
        for i in range(n, len(s)):
            res.append(s[i])
        for i in range(n):
            res.append(s[i])
        return ''.join(res)
```

【楼上的简化版本，利用求余运算】

【啊为什么别人想得到你想不到！！！】

```python
class Solution:
    def reverseLeftWords(self, s: str, n: int) -> str:
        res = []
        for i in range(n, n + len(s)):
            res.append(s[i % len(s)])
        return ''.join(res)
```



【再偷偷加一个自己在pycharm上编的不用函数的版本！】

```python
a = input('请输入字符串：')
k = int(input('请输入k：'))
print(a[k:] + a[:k])
```

