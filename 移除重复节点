【把节点值保存到数组里，然后遍历链表判断节点值是否在数组里】【注意这道题用a=set（）会比a=[]速度快得多】
【可以用单指针做，也可以用双指针；可以用虚拟头节点，也可以不用；要注意这几种解法的不同点和应该注意的点，没错我指的就是while判断时候后面是跟tmp还是tmp.next】
【链表的第一个节点是一定在数组里的，必须要注意链表为空的情况】
【如果该节点值在数组里，注意此时node.next=node.next.next，但是指针不移动。如果指针移动的话就会略过对node.next.next节点的判断】
【如果不得使用临时缓冲区，该怎么解决？← 这个问题复习时候需要考虑一哈】

【错误1：没有属性val】
class Solution:
    def removeDuplicateNodes(self, head: ListNode) -> ListNode:
        cur = head
        a =set()
        a.add(head.val)                          #第2个错误点（排序按照自己的思考情况，这个解法的主要错误就是它）：当链表为空，就没有属性val
        while cur.next:
            if cur.next.val in a:
                cur.next = cur.next.next         #第1个错误点：当cur.next为尾节点时，进行完这一步，cur为None，不存在cur.next【不对不对这个不是错误】
            else:                                #楼上这个不是错误，对while判定来说，不存在cur.next就直接跳出循环了
                a.add(cur.next.val)              #所以本题从头到尾都只有一个错误！！那就是没有考虑链表为空的情况！！
                cur = cur.next                   #所以不要初始化完a就急吼吼的把head.val加入a啊！！
        return head
【补充：1.单指针，无虚假链表头：如果while判定cur.next的话，必须先判定head是否为空；如果while判定cur的话，等一下，while不能判定cur！！
          如果while cur：，则无法移除重复节点，因为重复节点会是cur本点！（所以如果想while cur：的话，必须得是双指针）
          所以当【单指针，无虚假链表头】时，while cur.next：
        2.单指针，有虚假链表头：同样需要先判定head是否为空，while只能cur.next
        （answer1）
        3.双指针，无虚假链表头：while cur：，不需要先判定head是否为空；如果while判定cur.next的话，那就和单指针一样，没有双指针的意义
        4.双指针，有虚假链表头：while cur.next，不需要判定head是否为空（和单指针类似，因为多了个头，cur.next首先指向head，所以不需要判断head；所以这里也没写，复习时候有兴趣可以写一下）】
【综上所述：其实只有三种情况，单指针，双指针有虚假头（和单指针类似），双指针无虚假头（唯一一个能while cur：的）】 
【分下类：
  必须判定head是否为空：单指针；   不需要判定：双有头，双无头
  while cur.next：单指针，双有头； while cur：双无头】
 
【复盘时候看自己错的记录，哎哟这个傻孩子，一开始还以为是数组的问题，把a=set（）改成了a=[]，别的啥都没改又试了一次，可太蠢了】 
【重复一遍，a=set（）比a=[]速度快得多！】
      
【answer1：单指针，无虚假头节点（有没有都一样），注意while判断（这个解法就表明了，while是不会考虑cur.next存不存在的）】
class Solution:
    def removeDuplicateNodes(self, head: ListNode) -> ListNode:
        if head is None:
            return head
        cur = head
        a = set()
        a.add(head.val)
        while cur.next:
            if cur.next.val in a:
                cur.next = cur.next.next
            else:
                a.add(cur.next.val)
                cur = cur.next
        return head
        
【answer2：双指针，无虚假头节点，注意while判断】
class Solution:
    def removeDuplicateNodes(self, head: ListNode) -> ListNode:
        prev = tmp = head                       #这个解法不必先判定head是否为空
        a =set()
        while tmp:
            if tmp.val not in a:
                a.add(tmp.val)
                prev = tmp
                tmp = tmp.next
            else:
                tmp = tmp.next
                prev.next = tmp
        return head        
